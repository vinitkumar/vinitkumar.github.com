I"”#<h3 id="important-cross-posting-from-this-medium-article-httpsmediumcomsschillacecoding-principles-every-engineer-should-know-b946b48cc946-since-i-do-not-like-medium-as-a-platform-and-i-do-not-want-to-loose-this-port-in-matrix-">IMPORTANT: Cross posting from this medium article https://medium.com/@sschillace/coding-principles-every-engineer-should-know-b946b48cc946 since I do not like medium as a platform and I do not want to loose this port in matrix :)</h3>
<h3 id="the-post-has-been-written-by-sam-schillace-and-all-references-to-mei-is-referenced-to-mr-sam">The post has been written by <a href="https://medium.com/@sschillace">Sam Schillace</a> and all references to me/I is referenced to Mr. Sam</h3>

<p>Throughout my engineering career, Iâ€™ve had the opportunity work alongside and learn from many incredibly talented people, solve some serious technical challenges, and scale several successful companies. Recently, I was talking with the engineering team at Box about what Iâ€™ve learned along this journey, and what came out of that conversation were my personal engineering principals. These arenâ€™t rules or engineering guidelines. Theyâ€™re simply the principles that I pay attention to when I write and operate code.</p>

<h2 id="be-paranoid">Be paranoid.</h2>

<p>This one comes naturally to me. Since Iâ€™m mostly self-taught as a programmer, I never trust computers. I never trust that the system I just launched is really up. That the bug I fixed is really fixed. That code really does work the way I think it does without a test. I donâ€™t trust anything. I donâ€™t even trust myself! I never trust that I understand anything as well as I think I do until I check more than once. Paranoia is my friend, and it should be your friend, too. Always try to find a way to test assumptions along some other path, or get a second set of eyes to see what youâ€™ve missed. Most of the time itâ€™s not needed. Sometimes itâ€™s really important.</p>
<h2 id="dont-lie-to-the-computer">Donâ€™t lie to the computer.</h2>
<p>Another way to say this is â€œavoid leaky abstractions.â€ Donâ€™t use systems in ways theyâ€™re not meant to be used. Donâ€™t count on side effects. Donâ€™t do things that wonâ€™t be obvious to the next person because the system wasnâ€™t designed for them or theyâ€™re undocumented. If usage is three orders of magnitude more than current usage, then you should probably rethink the design. If the contract implies, but doesnâ€™t guarantee, your use, you should change the component and the contract to be aligned. Computers are nasty things. They always bite when lied to, eventually.</p>

<h2 id="keep-it-simple">Keep it simple.</h2>

<p>We like building things and solving problems. Thatâ€™s why we do what we do. But a lot of the time, just because we can see a problem that could be solved, doesnâ€™t mean itâ€™s useful to solve it right now. I always think of myself as a fairly dumb programmerâ€Šâ€”â€ŠI like clean, simple designs that are easy to understand. And this is a high challengeâ€Šâ€”â€Šanyone can solve a problem in a complex way, but only good programmers can solve problems in simple, understandable ways. Itâ€™s much harder to really think through the problem and solve only what needs to be solved in a simple, robust manner. Making yourself understood is the most important thing. Most time in code is spent maintaining, not creating.</p>

<h2 id="first-rule-of-optimizing-dont">First rule of optimizing: donâ€™t.</h2>

<p>This is from a good book by John Bentley called Programming Pearls. (Itâ€™s explicitly meant to help you learn to think like an experienced programmer. It may be an old book but most of the lessons are incredibly relevant today.) Optimization can take many forms: speed, future-proofing, potential scale, possible uses, etc. The problem is, most optimization is ultimately never used, and, more or less by definition, optimization makes designs more complicated. So, first rule of thumb is donâ€™t optimize until itâ€™s really clear that you understand the problem completely. (His second rule: â€œdonâ€™t optimize, yet.â€ Meaning, even if you do understand it, donâ€™t optimize until you really need to.)</p>

<h2 id="dont-just-fix-the-bug-fix-all-possibility-of-it-ever-happening-again">Donâ€™t just fix the bug; fix all possibility of it ever happening again.</h2>

<p>Donâ€™t be sorry if you made a mistakeâ€Šâ€”â€Šbe angry and make it something you never have to think about again. I hate bugs. I hate systems that let me create bugs. I hate it when my own software lets my fragile human brain down and I create a bug that could have been avoided. And I really, really hate fixing the same bug twice. So I try as much as I can, every single time I fix a bug, to think about the following: where else might this bug be happening now? Where might it happen in the future? What are the adjacent patterns that create similar bugs? And how can I kill all the bastards at once, right now?</p>

<h2 id="question-assumptions-constantly">Question assumptions constantly.</h2>

<p>Because I have spent most of my time in my own startups, Iâ€™ve gotten in the habit of asking myself constantly â€œWhy am I doing this? What problem does it solve? Is there a better way? Is there something else I could do instead thatâ€™s more important?â€ You should have that attitude all the time. Constantly be questioning the assumptions given to you. Whatâ€™s the real problem youâ€™re solving? Did someone ask you to solve an effect rather than the root cause? Is the solution complete? Over-complete? Is the impact worthwhile?</p>

<h2 id="think-long-term-slow-down-it-goes-faster">Think long term. Slow down, it goes faster.</h2>

<p>This might be one of the most important ones. Itâ€™s easy to hack things out. As engineers, we like efficiency; we like to build as many things as we can. But if we donâ€™t build for the long term, eventually it gets harder and harder to build anything. Sometimes we donâ€™t understand the problem at first and we write code that we later have to back out. Sometimes we do things that are easy for our local problem, but make things worse or harder for someone else or for a larger problem. Sometimes we rush and donâ€™t finish the design, and this causes much more time later on for someone to fix. Sometimes we donâ€™t bother to write it the right way, we just make a copy or hack something in because weâ€™re under time pressure or donâ€™t want to really think it through. Iâ€™ve seen all these things too many times. Others have said this better than I have. But Iâ€™ll repeatâ€Šâ€”â€Šthe goal is building the largest number of great features, reaching the largest number users over time. The area under the curve for a given day doesnâ€™t add much, no matter how much gets done on that day, relative to all the days added together. Think long term.</p>

<h2 id="care-about-your-code">Care about your code.</h2>

<p>I guess this one doesnâ€™t need much explanation, but itâ€™s still something I see people missing from time to time. Take pride in your work! Care about the code you produce! I usually think of my poor future self, having to deal with my crappy code, when Iâ€™m tempted to be lazy and cut a corner. You donâ€™t have to take this to an extremeâ€Šâ€”â€ŠI used to joke at Google that other engineers treated their code like a pet, where my relationship with mine was more like a ranchersâ€Šâ€”â€Špragmatic, not sentimental. But even still, I always hate it if my code isnâ€™t well designed, doesnâ€™t work well, isnâ€™t readable, all that stuff.</p>
<h2 id="cheap-fast-rightpick-two">Cheap, fast, rightâ€Šâ€”â€Špick two.</h2>

<p>This is the iron triangle of software. This is the way the world of software engineering works. But itâ€™s not an excuse for complacency. In fact, this is your opponent every single day. The difference between good and great programmers is often measured in how well they navigate the iron triangle. And really great ones find ways to bend it and get some of all three, more often than not. Try to be that kind of programmerâ€Šâ€”â€Šcan you find a more elegant design thatâ€™s faster to build and is still right? Can you relax some constraint in the spec to get to the goal more quickly? You might not always be able to do that; in fact, you wonâ€™t beat the triangle. But if nothing else, make sure you understand what compromise you are choosing, and why, and that itâ€™s the right one for the current situation.</p>

<h2 id="conclusion-be-curious-learn-as-much-as-you-can-all-the-time">Conclusion: Be curious. Learn as much as you can, all the time.</h2>

<p>Okay, this one is more career advice than anything else. But if youâ€™re not curious and donâ€™t really care that much about learning new things as an engineer and donâ€™t care about new tech or new languages or new ideas, then why are you here? By no means are my principles perfect or an absolute representation of thinking/acting like a successful engineer, but Iâ€™m willing to bet thereâ€™s a fair amount of overlap with what others might be thinking. Iâ€™d love to hear your thoughts.</p>

:ET